# 第十二章 类

类是核心

field

属性

定义属性，会自动的生成get和set方法 

针对每一个属性，都会产生一个field，一个getter，以及一个setter  field用来存储属性数数据 ，自己不可以定义field

```java
package kw.base.part12

class Player {
    var name = "xx";
    var addr:String? = null;
    var componyAddr:String? = null
        get() {
            if (field == null){
                return ""
            }else{
                return field
            }
        }
        set(value) {
            field = value + "xxxx"
        }

    var age:Int
        get() {
            return (1..6).shuffled().first()
        }
        set(value) {

        }

//    var agex: Int
//        get() = (1..6).shuffled().first()
}

fun main(args:Array<String>){
    var p = Player()
    p.name = "fjj"
}
```

## 定义一个类

类可以定义在一个独立的文件中，也可以和函数或者变量定义在一起。

类在单独的文件中可以给升级预留空间。

类名和文件名一样，也可以不一样  一个文件中可以定义多个类

```kotlin
class Player
```

### 定义构造

创建实体，必须实例化类，调用它的构造函数

```kotlin
var player = Player()
```

### 此构造函数

次构造函数也会调用主构造函数


### 给默认值

### 初始块


构造类函数中执行

```kotlin
init{

}
```

### 初始化块的执行顺序

- 主构造  
- 属性赋值
- init
- 次构造函数

### 延迟初始化

lateinit 用属性之前初始化

```kotlin
package kw.base.part12.App

/**
 * 延迟初始化
 */
class LateinitApp {
    lateinit var name :String

    fun ready(){
        name = "kw"
    }

    fun battle(){
        if (::name.isLateinit) println(name)
    }
}
```

### 惰性初始化

暂时不初始化，直到用的时候才进行初始化

写好初始化的函数，等到调用的时候才会执行初始化方法

```kotlin
by lazy
```

### 坑1

初始化顺序

### 坑2


### 类函数

类定义主要包含两类：行为和数据

```kotlin
class Player{
    fun createBall(){
        
    }
    
    fun xx(num :Int) = {
        println()
    }
}
```

### 封装可见性

类函数给某个类添加行为，不带有修饰符的就是public,有选择性的暴露叫做封装，

- public:默认,对于外部可见
- private：仅仅对自己可见
- protected：自己和子类
- internal ：同模块

### 类属性



## 继承

默认是不可以被继承的，需要使用open

## Any超类

any是所有类的超类

## Object

可以定义一个单例的对象 

使用object关键字有三种方式
- 对象声明
- 对象表达式
- 伴生对象

### 单例

1.对象名字，也可以对象实例的名字 
```kotlin
package kw.base.part12.App.jicheng

object Singleton {
    fun dosomething(){

    }
}

fun main(){
    Singleton.dosomething()
}
```

### 对象表达式

用完就丢的类实例，只用一次的类实例

```kotlin
package kw.base.part12.App.jicheng

open class ObClass2 {
    open fun dosomthing(){}
}

fun main(){
    val p = object : ObClass2(){
        override fun dosomthing() {
            super.dosomthing()
            println("------------------")
        }
    }
}
```

## 伴生对象 

某个类的初始化和类实例捆绑在一起，可以考虑伴生对象  一个类只有一个伴生对象


## 嵌套类

一个类只对，另一个类有用

## 数据类

专门存储数据的

重写了同String   equeal  hashcode

## copy

复制对象的 类似clone

copy创建对象，只会调用主构造不会执行次构造

## 解构声明


## 运算符重载

```kotlin
package kw.base.part12.App.jicheng

class JgApp(var name:String,var age:Int) {
    operator fun component1() = name
    operator fun component2() = age

    operator fun plus(other:JgApp) {
        JgApp(name+other.name,age + other.age)
    }
}

fun main(){

    var (name,age) = JgApp("xx",1903)


}
```
















